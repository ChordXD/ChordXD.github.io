---
title: 【动态规划】蓝桥杯 格子刷油漆
copyright: true
date: 2019-02-28 10:17:08
tags:
 - 动态规划
 - 蓝桥杯
categories:
 - 蓝桥杯
keywords:
description:
---

## 问题描述
　　X国的一段古城墙的顶端可以看成 2\*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。
![格子刷油漆](/photo/gz.jpg)
　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）
　　比如：a d b c e f 就是合格的刷漆顺序。
　　c e f d a b 是另一种合适的方案。
　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。
<!-- more -->
## 输入格式
　　输入数据为一个正整数（不大于1000）
## 输出格式
　　输出数据为一个正整数。
## 样例输入
	2
## 样例输出
	24
## 样例输入
	3
## 样例输出
	96
## 样例输入
	22
## 样例输出
	359635897

## 题意
给你一个2×n的网格，你可以走相邻的格子，问在不走已走过的格子的情况下，有多少种可行方案遍历所有的格子。
## 思路
动态规划，分两种情况讨论。
设置两个数组a,b，a数组表示从某个点出发任意点结束的所有情况。b数组表示从某个点出发且结束点为同列的另一个格子。
假设遍历格子次序从左到右。

一、从四个角出发，遍历所有的格子。对于这种情况又分两种情况讨论。
  **遍历中的遍历全部格子 = 遍历当前格子和其左边的格子。**
1. 第一种，从当前格子出发，结束为当前格子**同列相对**的格子。满足b数组要求，由于第一步可以走到左上或者左下，所以`b[i] = 2* ...` ，又因为走到左上或者左下的格子之后又变成了一个相同的问题，所以转移方程为`b[i] = 2*b[i-1]`
2. 第二种，从当前格子出发，结束位置为**任意**格子。满足a数组要求，第一步分三种情况
	1.  **向下走**，那么下一步就变成了从i-i位置开始的相同问题，所以这一种情况的转移方程为`2*a[i-1]`
	2. 向**左下方**走，此时又有两种情况
		1. 先往**右**走，之后往**左斜上方**走，走到出发位置的左手边，此时又变成了从i-2位置遍历所有的格子的问题，转移方程为`2*a[i-2]`
		2. 先向**左**走，遍历完所有格子之后回到正上方的格子。变成第一种情况的i-1版本，转移方程为`b[i-1]`。
	3. 向**左**方向走。此时可以分成两种情况。
		1. 向**右下方**走，之后只能往**左**走一格，然后可以往左上或者左手边走，然后又变成了一个，从i-2的格子出发遍历所有格子的问题，转移方程为`2*a[i-2]`
		2. 向左遍历完所有的格子最后回到同列相对的格子，转移方程为`b[i-1]`

整理一下在这个遍历当中的所有转移方程。
```c++
b[i] = 2*b[i-1]
a[i] = 4*a[i-2] + 2*a[i-1] + 2*b[i-1] = 4*a[i-2] + 2*a[i-1] + b[i]
```
因为一个长方体有四个角，所以遍历完所有的长度之后，ans = 4\*a[n]。
二、从非四个角出发，遍历所有的格子。
首先明确一点，从非四个角的点出发，都不可以第一步向下走，因为根据题目规则，这样行走只能遍历一半的点。
那么就变成了两种情况。
1. 第一种，从当前的格子出发，先向左走，回到当前格子同列的格子之后，再遍历右边所有的格子。转移方程为`b[i] * a[n-i]*2`因为遍历右边格子的时候可以选择从**右上**的格子开始遍历也可以选择从**右**手边的格子开始遍历，所以a[n-i]需要×2。**注意，这里遍历完一遍之后并没有遍历完所有的情况，所以左右情况应该相乘而不是相加。**
2. 第二种，从当前的格子出发，先往右走，回到当前格子同列的格子之后，再遍历左边的格子。原理同第一种，不再赘述。`b[n-i+1]*a[i-1]*2`

整理一下这两种情况。
由于每次可以从上方的格子开始遍历，也可以从下方的格子开始遍历，所以实际计算之后结果还要×2。
每一步的循环都得加到总结果当中。
```c++
	for(int i = 2 ; i < n ; i++)
	{
        sum += (2 * ((b[i] * a[n - i] * 2) % mod + (b[n - i + 1] * a[i - 1] * 2) % mod)) % mod;
        sum %= mod;
	}
```
## AC代码
```c++
评测结果	正确
得分	100
CPU使用	0ms
内存使用	2.449MB
#include <bits/stdc++.h>
using namespace std;
#define ll long long int
const int maxn = 1e5 + 7, mod = 1e9 + 7;
ll a[maxn], b[maxn];
void sovle(void)
{
	/*先预处理出前两步的数组*/
    a[1] = b[1] = 1;
    a[2] = 6, b[2] = 2;
    int n;
    scanf("%d", &n);
    for (int i = 3; i <= n; i++)
    {
        b[i] = b[i - 1] * 2;
        b[i] %= mod;
        a[i] = a[i - 1] * 2 + a[i - 2] * 4 + b[i]; //第一种情况。
        a[i] %= mod;
    }
    ll sum = 4 * a[n] % mod;
    for (int i = 2; i < n; i++)
    {
        sum += (2 * ((b[i] * a[n - i] * 2) % mod + (b[n - i + 1] * a[i - 1] * 2) % mod)) % mod; //第二种情况。
        sum %= mod;
    }
    if (n == 1)
        puts("1");
    else if (n == 2)
        puts("24");
    else
        printf("%lld\n", sum % mod);
}

int main(void)
{
    sovle();
    return 0;
}
```