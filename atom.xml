<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水滴是云</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="chordblog.com/"/>
  <updated>2019-07-19T11:49:35.598Z</updated>
  <id>chordblog.com/</id>
  
  <author>
    <name>Chord</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【栈】2019牛客暑期多校训练营（第一场）A Equivalent Prefixes</title>
    <link href="chordblog.com/%E3%80%90%E6%A0%88%E3%80%912019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89A-Equivalent-Prefixes.html"/>
    <id>chordblog.com/【栈】2019牛客暑期多校训练营（第一场）A-Equivalent-Prefixes.html</id>
    <published>2019-07-19T07:42:50.000Z</published>
    <updated>2019-07-19T11:49:35.598Z</updated>
    
    <content type="html"><![CDATA[<p>题目连接：<a href="https://ac.nowcoder.com/acm/contest/881/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/881/A</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于两个数组区间l,r ，rmq相等的定义是：对于l,r内任意子区间rmq值的对应数组下标都相等（即任意子区间的最小值对应的下标都相等），那么这两个数组的l,r区间RMQ相等。</p><p>现在问你给你两个序列，存在若干R，能使两个序列下标1~R的区间的rmq相等，现在问你最大的R值是多少。</p><a id="more"></a><p>解释一下样例：</p><p>样例三<br>5<br>3 1 5 2 4<br>5 2 4 3 1</p><p>很明显，对于从1~4的区间，两个序列的任意子序列的rmq所对应的下标值都相同，</p><p>但是在1~5区间：</p><p>序列1所对应的最小值是1，值所对应的下标值是2。</p><p>序列2所对应的最小值是1，值所对应的下标值是5.</p><p>下标值并不相同，所以R最大只能为4</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比赛中：</p><p>线段树一顿操作，又RE又TLE又WA。</p><p>事实上：</p><p>每个元素ai可以影响到RMQ值的区间为1 to  i-1,而由RMQ的性质可知，其最只能影响所有比他大的值，而若遇见了一个比aj,则其无法影响包含aj的区间。</p><p>由于我们是求1~r的区间，我们只需要对于每个插入元素ai,观察其在其之间究竟能影响多少元素，由上文可知，若对于元素i,在其<strong>之前</strong>存在元素j，且元素ai &lt; aj,则元素i的影响范围只能到j,即元素i的影响范围是j\to i,注意这里的i &gt; j.</p><p>那么我们只需要记录一下对于每个元素i其能在其之前所能影响到的最大范围的序列下标值j记录一下，之后将两个数组比对一下。若两个序列的前r区间RMQ性质相同，则其所算出的前文的记录值序列也应相同。找到第一个不相同的位置的前一个位置即为答案。</p><p>代码实现使用栈进行维护一个单调递增的栈，对于每个新插入的元素将其前面比起值大的元素从栈中移除，则未移除的第一个元素的下标值即为上文中我们需要记录的记录值。</p><p>不难发现，若下一个元素比前一元素小，则当前元素删除的值即使不删除对于下一元素也毫无意义，也会被删除，若下一元素元素值比前一元素大，则下意元素的影响范围只有其本身，其秩序记录最大范围的下标值即为当前元素的坐标即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ***********************************************</span></span><br><span class="line"><span class="comment">Author :Chord</span></span><br><span class="line"><span class="comment">Email:pengrj2018@gmail.com</span></span><br><span class="line"><span class="comment">Created Time :2019/7/19 13:56:15</span></span><br><span class="line"><span class="comment">File Name :new.cpp</span></span><br><span class="line"><span class="comment">************************************************ */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt;p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans(n);</span><br><span class="line">    p.emplace_back(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n ;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">while</span>(p.back().first &gt; a)</span><br><span class="line">            p.pop_back();</span><br><span class="line">        ans[i] = p.back().second;</span><br><span class="line">        p.emplace_back(a,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = solve();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b = solve();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n &amp;&amp; a[l] == b[l])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目连接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/881/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/881/A&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;对于两个数组区间l,r ，rmq相等的定义是：对于l,r内任意子区间rmq值的对应数组下标都相等（即任意子区间的最小值对应的下标都相等），那么这两个数组的l,r区间RMQ相等。&lt;/p&gt;
&lt;p&gt;现在问你给你两个序列，存在若干R，能使两个序列下标1~R的区间的rmq相等，现在问你最大的R值是多少。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="chordblog.com/tags/%E6%A0%88/"/>
    
      <category term="笛卡尔树" scheme="chordblog.com/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【第k大01背包】HDU Bone Collector II</title>
    <link href="chordblog.com/%E3%80%90%E7%AC%ACk%E5%A4%A701%E8%83%8C%E5%8C%85%E3%80%91HDU-Bone-Collector-II.html"/>
    <id>chordblog.com/【第k大01背包】HDU-Bone-Collector-II.html</id>
    <published>2019-07-17T01:52:39.000Z</published>
    <updated>2019-07-19T11:43:47.244Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>The title of this problem is familiar,isn’t it?yeah,if you had took part in the “Rookie Cup” competition,you must have seem this title.If you haven’t seen it before,it doesn’t matter,I will give you a link:</p><p>Here is the link:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2602</a></p><p>Today we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get the same value of bones are the same.That means,it will be a strictly decreasing sequence from the 1st maximum , 2nd maximum .. to the K-th maximum.</p><p>If the total number of different values is less than K,just ouput 0.</p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, K(N &lt;= 100 , V &lt;= 1000 , K &lt;= 30)representing the number of bones and the volume of his bag and the K we need. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>One integer per line representing the K-th maximum of the total value (this number will be less than 231).</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 10 2</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">5 10 12</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">5 10 16</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>teddy</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>百万秦关终属楚</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求01背包的第k大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不断维护每个体积背包的前K大值的堆，反复从两个背包中的K大堆中选出前k大，形成一个新堆。<br>复杂度是O(NMK)。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">40</span>],s1[maxn],s2[maxn],tj[maxn],jz[maxn],n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;jz[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tj[i];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(s1,<span class="number">0</span>,<span class="keyword">sizeof</span> s1);</span><br><span class="line">        <span class="built_in">memset</span>(s2,<span class="number">0</span>,<span class="keyword">sizeof</span> s2);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"yes"&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= tj[i] ; j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= k ; p++)&#123;</span><br><span class="line">                    s1[p] = dp[j][p];</span><br><span class="line">                    s2[p] = dp[j - tj[i]][p] + jz[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*防止对比数组越界*/</span></span><br><span class="line">                s1[k+<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                s2[k+<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">1</span>,op = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(op &lt;= k &amp;&amp; (a &lt;= k || b &lt;= k))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s1[a] &gt; s2[b]) dp[j][op] = s1[a++];</span><br><span class="line">                    <span class="keyword">else</span> dp[j][op] = s2[b++];</span><br><span class="line">                    <span class="keyword">if</span>(dp[j][op] != dp[j][op - <span class="number">1</span>] || op == <span class="number">1</span>)</span><br><span class="line">                        op++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[m][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;p&gt;The title of this problem is familiar,isn’t it?yeah,if you had took part in the “Rookie Cup” competition,you must have seem this title.If you haven’t seen it before,it doesn’t matter,I will give you a link:&lt;/p&gt;
&lt;p&gt;Here is the link:&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2602&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=2602&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Today we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get the same value of bones are the same.That means,it will be a strictly decreasing sequence from the 1st maximum , 2nd maximum .. to the K-th maximum.&lt;/p&gt;
&lt;p&gt;If the total number of different values is less than K,just ouput 0.&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="chordblog.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="01背包" scheme="chordblog.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85/"/>
    
    
      <category term="背包" scheme="chordblog.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>【负数01背包】POJ 2184 Cowow Exhibition</title>
    <link href="chordblog.com/%E3%80%90%E8%B4%9F%E6%95%B001%E8%83%8C%E5%8C%85%E3%80%91POJ-2184-Cowow-Exhibition.html"/>
    <id>chordblog.com/【负数01背包】POJ-2184-Cowow-Exhibition.html</id>
    <published>2019-07-16T12:18:43.000Z</published>
    <updated>2019-07-19T11:43:47.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>“Fat and docile, big and dumb, they look so stupid, they aren’t much<br>fun…” </p><ul><li>Cows with Guns by Dana Lyons </li></ul><p>The cows want to prove to the public that they are both smart and fun. In order to do this, Bessie has organized an exhibition that will be put on by the cows. She has given each of the N (1 &lt;= N &lt;= 100) cows a thorough interview and determined two values for each cow: the smartness Si (-1000 &lt;= Si &lt;= 1000) of the cow and the funness Fi (-1000 &lt;= Fi &lt;= 1000) of the cow. </p><p>Bessie must choose which cows she wants to bring to her exhibition. She believes that the total smartness TS of the group is the sum of the Si’s and, likewise, the total funness TF of the group is the sum of the Fi’s. Bessie wants to maximize the sum of TS and TF, but she also wants both of these values to be non-negative (since she must also show that the cows are well-rounded; a negative TS or TF would ruin this). Help Bessie maximize the sum of TS and TF without letting either of these values become negative. </p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><ul><li><p>Line 1: A single integer N, the number of cows </p></li><li><p>Lines 2..N+1: Two space-separated integers Si and Fi, respectively the smartness and funness for each cow.<br>Output</p></li><li><p>Line 1: One integer: the optimal sum of TS and TF such that both TS and TF are non-negative. If no subset of the cows has non-negative TS and non- negative TF, print 0. </p></li></ul><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-5 7</span><br><span class="line">8 -6</span><br><span class="line">6 -3</span><br><span class="line">2 1</span><br><span class="line">-8 -5</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>OUTPUT DETAILS: </p><p>Bessie chooses cows 1, 3, and 4, giving values of TS = -5+6+2 = 3 and TF<br>= 7-3+1 = 5, so 3+5 = 8. Note that adding cow 2 would improve the value<br>of TS+TF to 10, but the new value of TF would be negative, so it is not<br>allowed. </p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>USACO 2003 Fall</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n只牛，每只牛有两个属性幽默感和智慧，现在你需要选择一些牛出来使其的幽默感和智慧值之和最大，且所有牛的幽默感和智慧值均不能为负数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题由于有负数，所以需要将dp数组偏移1e5个范围，使负数的值变为正数。</p><p>之后我们就可以把其堪称一个价值为智商，体积是幽默感的01背包或者反过来的01背包都行。<br>s<br>但是这里注意一点，若以价值为智商的时候，若智商为正数，则正常按照01背包从后向前遍历dp数组；反之应该从前往后遍历数组。原因很简单，应为01背包保证每个物品只能被使用一次，即任意一个状态被更新之后不得再次被使用，若为正数则从后往前遍历可以保证，若为负数，则转移公式中的dp[j - tf[i]]会向后移动，此时从前往后移动遍历满足01背包要求。</p><p>最后从dp[1e5]开始查找最大的背包价值即可，背包价值就是dp值+上数组下标。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ***********************************************</span></span><br><span class="line"><span class="comment">Author :Chord</span></span><br><span class="line"><span class="comment">Email:pengrj2018@gmail.com</span></span><br><span class="line"><span class="comment">Created Time :2019年07月16日 星期二 10时34分30秒</span></span><br><span class="line"><span class="comment">File Name :poj2184.cpp</span></span><br><span class="line"><span class="comment"> ************************************************ */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],PY = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> ts[<span class="number">106</span>],tf[<span class="number">106</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,-INF,<span class="keyword">sizeof</span> dp);</span><br><span class="line">dp[PY] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;  i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ts[i]&gt;&gt;tf[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ts[i] &lt; <span class="number">0</span> &amp;&amp; tf[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(tf[i] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= PY*<span class="number">2</span> + tf[i] ; j++)</span><br><span class="line">dp[j] = max(dp[j],dp[j - tf[i]] + ts[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = PY*<span class="number">2</span> ; j &gt;= tf[i] ; j--)</span><br><span class="line">dp[j] = max(dp[j],dp[j - tf[i]] + ts[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = PY ; i &lt;= PY*<span class="number">2</span> ; i++)</span><br><span class="line"><span class="keyword">if</span>(dp[i] &gt; <span class="number">0</span>) ans = max(dp[i] +i - PY , ans);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("out.txt","w",stdout);</span></span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;“Fat and docile, big and dumb, they look so stupid, they aren’t much&lt;br&gt;fun…” &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cows with Guns by Dana Lyons &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The cows want to prove to the public that they are both smart and fun. In order to do this, Bessie has organized an exhibition that will be put on by the cows. She has given each of the N (1 &amp;lt;= N &amp;lt;= 100) cows a thorough interview and determined two values for each cow: the smartness Si (-1000 &amp;lt;= Si &amp;lt;= 1000) of the cow and the funness Fi (-1000 &amp;lt;= Fi &amp;lt;= 1000) of the cow. &lt;/p&gt;
&lt;p&gt;Bessie must choose which cows she wants to bring to her exhibition. She believes that the total smartness TS of the group is the sum of the Si’s and, likewise, the total funness TF of the group is the sum of the Fi’s. Bessie wants to maximize the sum of TS and TF, but she also wants both of these values to be non-negative (since she must also show that the cows are well-rounded; a negative TS or TF would ruin this). Help Bessie maximize the sum of TS and TF without letting either of these values become negative. &lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="chordblog.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="01背包" scheme="chordblog.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85/"/>
    
    
      <category term="背包" scheme="chordblog.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>【树】POJ 2003 Hire and Fire</title>
    <link href="chordblog.com/%E3%80%90%E6%A0%91%E3%80%91POJ-2003-Hire-and-Fire.html"/>
    <id>chordblog.com/【树】POJ-2003-Hire-and-Fire.html</id>
    <published>2019-05-13T14:13:35.000Z</published>
    <updated>2019-07-19T11:43:47.229Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 1000 MS Memory Limit: 30000 KB</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>In this problem, you are asked to keep track of the hierarchical structure of an organization’s changing staff. As the first event in the life of an organization, the Chief Executive Officer (CEO) is named. Subsequently, any number of hires and fires can occur. Any member of the organization (including the CEO) can hire any number of direct subordinates, and any member of the organization (including the CEO) can be fired. The organization’s hierarchical structure can be represented by a tree. Consider the example shown by Figure 1:<br><img src="http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_desc_001.jpg" alt="photo1"><br>VonNeumann is the CEO of this organization. VonNeumann has two direct subordinates: Tanenbaum and Dijkstra. Members of the organization who are direct subordinates of the same member are ranked by their respective seniority. In the diagram, the seniority of such members decrease from left to right. For example Tanenbaum has higher seniority than Dijkstra. </p><p>When a member hires a new direct subordinate, the newly hired subordinate has lower seniority than any other direct subordinates of the same member. For example, if VonNeumann (in Figure 1) hires Shannon, then VonNeumann’s direct subordinates are Tanenbaum, Dijkstra, and Shannon in order of decreasing seniority. </p><p>When a member of the organization gets fired, there are two possible scenarios. If the victim (the person who gets fired) had no subordinates, then he/she will be simply dropped from the organization’s hierarchy. If the victim had any subordinates, then his/her highest ranking (by seniority) direct subordinate will be promoted to fill the resulting vacancy. The promoted person will also inherit the victim’s seniority. Now, if the promoted person also had some subordinates then his/her highest ranking direct subordinate will similarly be promoted, and the promotions will cascade down the hierarchy until a person having no subordinates has been promoted. In Figure 1, if Tanenbaum gets fired, then Stallings will be promoted to Tanenbaum’s position and seniority, and Knuth will be promoted to Stallings’ previous position and seniority. </p><p>Figure 2 shows the hierarchy resulting from Figure 1 after (1) VonNeumann hires Shannon and (2) Tanenbaum gets fired:<br><img src="http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_desc_002.jpg" alt="photo2"></p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input contains only the name of the person who is initially the CEO. All names in the input file consist of 2 to 20 characters, which may be upper or lower case letters, apostrophes, and hyphens. (In particular, no blank spaces.) Each name contains at least one upper case and at least one lower case letter. </p><p>The first line will be followed by one or more additional lines. The format of each of these lines will be determined by one of the following three rules of syntax: </p><p>[existing member] hires [new member]<br>fire [existing member]<br>print</p><p>Here [existing member] is the name of any individual who is already a member of the organization, [new member] is the name of an individual who is not a member of the organization as yet. The three types of lines (hires, fire, and print) can appear in any order, any number of times. </p><p>You may assume that at any time there is at least one member (who is the CEO) and no more than 1000 members in the organization. </p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each print command, print the current hierarchy of the organization, assuming all hires and fires since the beginning of the input have been processed as explained above. Tree diagrams (such as those in Figures 1 and 2) are translated into textual format according to the following rules:<br>Each line in the textual representation of the tree will contain exactly one name.<br>The first line will contain the CEO’s name, starting in column 1.<br>The entire tree, or any sub-tree, having the form<br><img src="http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_output_001.jpg" alt><br>will be represented in textual form as:<br><img src="http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_output_002.jpg" alt><br>The output resulting from each print command in the input will be terminated by one line consisting of exactly 60 hyphens. There will not be any blank lines in the output.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VonNeumann</span><br><span class="line">VonNeumann hires Tanenbaum</span><br><span class="line">VonNeumann hires Dijkstra</span><br><span class="line">Tanenbaum hires Stallings</span><br><span class="line">Tanenbaum hires Silberschatz</span><br><span class="line">Stallings hires Knuth</span><br><span class="line">Stallings hires Hamming</span><br><span class="line">Stallings hires Huffman</span><br><span class="line">print</span><br><span class="line">VonNeumann hires Shannon</span><br><span class="line">fire Tanenbaum</span><br><span class="line">print</span><br><span class="line">fire Silberschatz</span><br><span class="line">fire VonNeumann</span><br><span class="line">print</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">VonNeumann</span><br><span class="line">+Tanenbaum</span><br><span class="line">++Stallings</span><br><span class="line">+++Knuth</span><br><span class="line">+++Hamming</span><br><span class="line">+++Huffman</span><br><span class="line">++Silberschatz</span><br><span class="line">+Dijkstra</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">VonNeumann</span><br><span class="line">+Stallings</span><br><span class="line">++Knuth</span><br><span class="line">+++Hamming</span><br><span class="line">+++Huffman</span><br><span class="line">++Silberschatz</span><br><span class="line">+Dijkstra</span><br><span class="line">+Shannon</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Stallings</span><br><span class="line">+Knuth</span><br><span class="line">++Hamming</span><br><span class="line">+++Huffman</span><br><span class="line">+Dijkstra</span><br><span class="line">+Shannon</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>Rocky Mountain 2004</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个树，父节点是孩子节点的上司，孩子节点从左到右级别依次递减。<br>现在有三个操作，一个操作是打印这棵树，第二个操作是删除一个节点，之后该节点的孩子节点的级别最大的节点代替删除掉的节点，并且代替之后该孩子节点删除，对该孩子节点的删除操作同上，直到某一个节点没有孩子节点。<br>第三个操作是对于任意的一个节点增加一个孩子节点，并将其放置在树的最右端（优先级最校）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>模拟嘛，一顿模拟就完了。<br>List操作不熟欸。<br>删除操作实际上就是把删除节点的所有左第一个儿子（包括儿子的儿子们）向上提升一个层次。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poi</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Poi *f;</span><br><span class="line">    <span class="built_in">list</span>&lt;Poi *&gt;son;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Poi()</span><br><span class="line">    &#123;</span><br><span class="line">        f = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,Poi*&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fire</span><span class="params">(<span class="built_in">string</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poi *now = p[n];</span><br><span class="line">    <span class="keyword">while</span>(now-&gt;son.size()!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        now-&gt;name = now-&gt;son.front()-&gt;name;</span><br><span class="line">        p[now-&gt;name] = now;</span><br><span class="line">        now = now-&gt;son.front();</span><br><span class="line">    &#125;</span><br><span class="line">    now-&gt;f-&gt;son.remove(now);</span><br><span class="line">    <span class="keyword">delete</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Poi *now,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; deep ; i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"+"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;now-&gt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;Poi*&gt;::iterator it = now-&gt;son.begin();</span><br><span class="line">    <span class="keyword">while</span>(it!=now-&gt;son.end())</span><br><span class="line">    &#123;</span><br><span class="line">        print(*it,deep+<span class="number">1</span>);</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poi *f = p[a];</span><br><span class="line">    Poi *s = <span class="keyword">new</span> Poi();</span><br><span class="line">    s-&gt;name = b;</span><br><span class="line">    p[b] = s;</span><br><span class="line">    f-&gt;son.push_back(s);</span><br><span class="line">    s-&gt;f = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> boss;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;boss;</span><br><span class="line">    Poi *Boss = <span class="keyword">new</span> Poi();</span><br><span class="line">    Boss-&gt;name = boss;</span><br><span class="line">    <span class="built_in">string</span> a,b,c;</span><br><span class="line">    p[boss] = Boss;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="string">"print"</span>)&#123;</span><br><span class="line">            print(Boss,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">60</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"-"</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="string">"fire"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">            fire(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            add(a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 1000 MS Memory Limit: 30000 KB&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;In this problem, you are asked to keep track of the hierarchical structure of an organization’s changing staff. As the first event in the life of an organization, the Chief Executive Officer (CEO) is named. Subsequently, any number of hires and fires can occur. Any member of the organization (including the CEO) can hire any number of direct subordinates, and any member of the organization (including the CEO) can be fired. The organization’s hierarchical structure can be represented by a tree. Consider the example shown by Figure 1:&lt;br&gt;&lt;img src=&quot;http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_desc_001.jpg&quot; alt=&quot;photo1&quot;&gt;&lt;br&gt;VonNeumann is the CEO of this organization. VonNeumann has two direct subordinates: Tanenbaum and Dijkstra. Members of the organization who are direct subordinates of the same member are ranked by their respective seniority. In the diagram, the seniority of such members decrease from left to right. For example Tanenbaum has higher seniority than Dijkstra. &lt;/p&gt;
&lt;p&gt;When a member hires a new direct subordinate, the newly hired subordinate has lower seniority than any other direct subordinates of the same member. For example, if VonNeumann (in Figure 1) hires Shannon, then VonNeumann’s direct subordinates are Tanenbaum, Dijkstra, and Shannon in order of decreasing seniority. &lt;/p&gt;
&lt;p&gt;When a member of the organization gets fired, there are two possible scenarios. If the victim (the person who gets fired) had no subordinates, then he/she will be simply dropped from the organization’s hierarchy. If the victim had any subordinates, then his/her highest ranking (by seniority) direct subordinate will be promoted to fill the resulting vacancy. The promoted person will also inherit the victim’s seniority. Now, if the promoted person also had some subordinates then his/her highest ranking direct subordinate will similarly be promoted, and the promotions will cascade down the hierarchy until a person having no subordinates has been promoted. In Figure 1, if Tanenbaum gets fired, then Stallings will be promoted to Tanenbaum’s position and seniority, and Knuth will be promoted to Stallings’ previous position and seniority. &lt;/p&gt;
&lt;p&gt;Figure 2 shows the hierarchy resulting from Figure 1 after (1) VonNeumann hires Shannon and (2) Tanenbaum gets fired:&lt;br&gt;&lt;img src=&quot;http://acm.hrbust.edu.cn/vj/oj_static/poj/2003_desc_002.jpg&quot; alt=&quot;photo2&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="chordblog.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【树】POJ 1330 Nearest Common Ancestors</title>
    <link href="chordblog.com/%E3%80%90%E6%A0%91%E3%80%91POJ-1330-Nearest-Common-Ancestors.html"/>
    <id>chordblog.com/【树】POJ-1330-Nearest-Common-Ancestors.html</id>
    <published>2019-05-12T15:48:31.000Z</published>
    <updated>2019-07-19T11:43:47.213Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 1000MS        Memory Limit: 10000K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:<br><img src="http://poj.org/images/1330_1.jpg" alt="格子刷油漆"><br>In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is. </p><p>For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y. </p><p>Write a program that finds the nearest common ancestor of two distinct nodes in a tree.<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,…, N. Each of the next N -1 lines contains a pair of integers that represent an edge –the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2<br>16<br>1 14<br>8 5<br>10 16<br>5 9<br>4 6<br>8 4<br>4 10<br>1 13<br>6 15<br>10 11<br>6 7<br>10 2<br>16 3<br>8 1<br>16 12<br>16 7<br>5<br>2 3<br>3 4<br>3 1<br>1 5<br>3 5</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>3</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>Taejon 2002</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一棵树，问你给出的两个节点最近的共同祖先节点是谁。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很简单。</p><ol><li>首先找到跟节点。具体方法与并查集的思想差不多，每个节点存储自己老爹的编号，然后唯一那个没有老爹的（就是存储的编号是自己的那个节点就是根节点）。</li><li>之后处理出所有节点的深度。任意一个节点的深度等于父节点深度+1，其所有儿子节点的深度等于其自身节点深度+1，那么我们可以从父节点出发，写一个dfs，处理出所有节点的深度。</li><li>然后也非常简单，对于任意两个节点，如果其不同，则找其的老爹节点，并更新这两个节点的值。至于找谁老爹的节点呢？毫无疑问是找深度更深的节点的老爹节点，并更新。直到这俩节点相同就说明找到了他们共同最近的老爹节点。因为必然老爹节点的深度相同嘛。</li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> DEEP[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p[maxn]; <span class="comment">//存每个节点的儿子节点。</span></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> deep)</span> <span class="comment">// 处理出所有节点的深度。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DEEP[n] = deep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p[n].size() ; i++)&#123;</span><br><span class="line">        dfs(p[n][i],deep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="comment">/*千万别忘了初始化*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ;  i++)&#123;</span><br><span class="line">            p[i].clear();</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(DEEP,INF,<span class="keyword">sizeof</span> DEEP);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ;  i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            f[y] = x;</span><br><span class="line">            p[x].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[root]!=root)&#123;</span><br><span class="line">            root = f[root];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="comment">/*不同则找层数更深的老爹，并更新*/</span></span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(DEEP[x] &gt; DEEP[y]) x = f[x];</span><br><span class="line">            <span class="keyword">else</span> y = f[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 1000MS        Memory Limit: 10000K&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:&lt;br&gt;&lt;img src=&quot;http://poj.org/images/1330_1.jpg&quot; alt=&quot;格子刷油漆&quot;&gt;&lt;br&gt;In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is. &lt;/p&gt;
&lt;p&gt;For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y. &lt;/p&gt;
&lt;p&gt;Write a program that finds the nearest common ancestor of two distinct nodes in a tree.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="chordblog.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【左偏树】洛谷 P1456 Monkey King</title>
    <link href="chordblog.com/%E3%80%90%E5%B7%A6%E5%81%8F%E6%A0%91%E3%80%91%E6%B4%9B%E8%B0%B7-P1456-Monkey-King.html"/>
    <id>chordblog.com/【左偏树】洛谷-P1456-Monkey-King.html</id>
    <published>2019-05-04T15:46:49.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Once in a forest, there lived N aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can’t avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.</p><p>Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, 10 will be reduced to 5 and 5 will be reduced to 2).</p><p>And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel.</p><p>一开始有n只孤独的猴子，然后他们要打m次架，每次打架呢，都会拉上自己朋友最牛叉的出来跟别人打，打完之后战斗力就会减半，每次打完架就会成为朋友（正所谓不打不相识o(∩_∩)o ）。问每次打完架之后那俩猴子最牛叉的朋友战斗力还有多少，若朋友打架就输出-1.</p><a id="more"></a><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>There are several test cases, and each case consists of two parts.</p><p>First part: The first line contains an integer N(N&lt;=100,000), which indicates the number of monkeys. And then N lines follows. There is one number on each line, indicating the strongness value of ith monkey(&lt;=32768).</p><p>Second part: The first line contains an integer M(M&lt;=100,000), which indicates there are M conflicts happened. And then M lines follows, each line of which contains two integers x and y, indicating that there is a conflict between the Xth monkey and Yth.</p><p>有多组数据</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>For each of the conflict, output -1 if the two monkeys know each other, otherwise output the strength value of the strongest monkey among all of its friends after the duel.</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">20</span><br><span class="line">16</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure></p><p>输出样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">-1</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>说明<br>题目可能有多组数据</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>左偏树模板，注意更新数据的操作。<br>先把打架的猴子拆出来，然后把他的儿子合并了，再把他合并进去。<br>最后把两堆猴子合并。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[0]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F[x] == x ? x : F[x] = Find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Son[<span class="number">2</span>], dis, val;</span><br><span class="line">&#125;S[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)<span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span> (S[x].val &lt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &lt; y))</span><br><span class="line">        swap(x, y);</span><br><span class="line">    rs = Union(rs, y);</span><br><span class="line">    <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) </span><br><span class="line">        swap(ls, rs);</span><br><span class="line">    F[x] = F[ls] = F[rs] = x;</span><br><span class="line">    S[x].dis = S[rs].dis + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S[x].val /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> rt = Union(ls, rs);</span><br><span class="line">    ls = rs = <span class="number">0</span>;</span><br><span class="line">    F[x] = rt;</span><br><span class="line">    <span class="keyword">return</span> Union(rt, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; S[i].val;</span><br><span class="line">            S[i].dis = <span class="number">0</span>;</span><br><span class="line">            F[i] = i;</span><br><span class="line">            S[i].Son[<span class="number">0</span>] = S[i].Son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">int</span> aa = Find(a);</span><br><span class="line">            <span class="keyword">int</span> bb = Find(b);</span><br><span class="line">            <span class="keyword">if</span> (aa == bb)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ansrt = Union(Updata(aa), Updata(bb));</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; S[ansrt].val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Once in a forest, there lived N aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can’t avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.&lt;/p&gt;
&lt;p&gt;Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, 10 will be reduced to 5 and 5 will be reduced to 2).&lt;/p&gt;
&lt;p&gt;And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel.&lt;/p&gt;
&lt;p&gt;一开始有n只孤独的猴子，然后他们要打m次架，每次打架呢，都会拉上自己朋友最牛叉的出来跟别人打，打完之后战斗力就会减半，每次打完架就会成为朋友（正所谓不打不相识o(∩_∩)o ）。问每次打完架之后那俩猴子最牛叉的朋友战斗力还有多少，若朋友打架就输出-1.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="左偏树" scheme="chordblog.com/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【左偏树】洛谷 P2713 罗马游戏</title>
    <link href="chordblog.com/%E3%80%90%E5%B7%A6%E5%81%8F%E6%A0%91%E3%80%91%E6%B4%9B%E8%B0%B7-P2713-%E7%BD%97%E9%A9%AC%E6%B8%B8%E6%88%8F.html"/>
    <id>chordblog.com/【左偏树】洛谷-P2713-罗马游戏.html</id>
    <published>2019-05-04T15:36:44.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗马皇帝很喜欢玩杀人游戏。 他的军队里面有n个人，每个人都是一个独立的团。最近举行了一次平面几何测试，每个人都得到了一个分数。 皇帝很喜欢平面几何，他对那些得分很低的人嗤之以鼻。<br>他决定玩这样一个游戏。 它可以发两种命令：<br>Merger(i, j)。把i所在的团和j所在的团合并成一个团。如果i, j有一个人是死人，那么就忽略该命令。<br>Kill(i)。把i所在的团里面得分最低的人杀死。如果i这个人已经死了，这条命令就忽略。<br>皇帝希望他每发布一条kill命令，下面的将军就把被杀的人的分数报上来。（如果这条命令被忽略，那么就报0分）</p><a id="more"></a><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行一个整数n（1&lt;=n&lt;=1000000）。n表示士兵数，m表示总命令数。<br>第二行n个整数，其中第i个数表示编号为i的士兵的分数。（分数都是[0..10000]之间的整数）<br>第三行一个整数m(1&lt;=m&lt;=100000) 第3+i行描述第i条命令。命令为如下两种形式： 1. M i j 2. K i</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果命令是Kill，对应的请输出被杀人的分数。（如果这个人不存在，就输出0）</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">100 90 66 99 10</span><br><span class="line">7</span><br><span class="line">M 1 5</span><br><span class="line">K 1</span><br><span class="line">K 1</span><br><span class="line">M 2 3</span><br><span class="line">M 3 4</span><br><span class="line">K 5</span><br><span class="line">K 4</span><br></pre></td></tr></table></figure></p><p>输出样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">100</span><br><span class="line">0</span><br><span class="line">66</span><br></pre></td></tr></table></figure></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>RT</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>左偏树<br>一定要记得删除的时候的操作，先val = -1，再将所有的儿子的父亲节点指向自己。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, Son[<span class="number">2</span>], val;</span><br><span class="line">&#125;S[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F[x] == x ? x : F[x] = Find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y);</span><br><span class="line">    rs = Union(rs, y);</span><br><span class="line">    <span class="keyword">if</span> (S[rs].dis &gt; S[ls].dis) swap(rs, ls);</span><br><span class="line">    F[x] = F[ls] = F[rs] = x;</span><br><span class="line">    S[x].dis = S[rs].dis + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S[x].val = <span class="number">-1</span>;</span><br><span class="line">    F[ls] = ls;</span><br><span class="line">    F[rs] = rs;</span><br><span class="line">    <span class="keyword">return</span> F[x] = Union(ls, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; S[i].val;</span><br><span class="line">        F[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    S[<span class="number">0</span>].dis = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">'K'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (S[x].val == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Find(x);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; S[t].val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                Pop(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; b;</span><br><span class="line">            <span class="keyword">int</span> aa = Find(x);</span><br><span class="line">            <span class="keyword">int</span> bb = Find(b);</span><br><span class="line">            <span class="keyword">if</span> (S[x].val == <span class="number">-1</span> || S[b].val == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (aa != bb) &#123;</span><br><span class="line">                Union(aa, bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;罗马皇帝很喜欢玩杀人游戏。 他的军队里面有n个人，每个人都是一个独立的团。最近举行了一次平面几何测试，每个人都得到了一个分数。 皇帝很喜欢平面几何，他对那些得分很低的人嗤之以鼻。&lt;br&gt;他决定玩这样一个游戏。 它可以发两种命令：&lt;br&gt;Merger(i, j)。把i所在的团和j所在的团合并成一个团。如果i, j有一个人是死人，那么就忽略该命令。&lt;br&gt;Kill(i)。把i所在的团里面得分最低的人杀死。如果i这个人已经死了，这条命令就忽略。&lt;br&gt;皇帝希望他每发布一条kill命令，下面的将军就把被杀的人的分数报上来。（如果这条命令被忽略，那么就报0分）&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="可并堆" scheme="chordblog.com/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【左偏树】洛谷 P3377 左偏树（可并堆）</title>
    <link href="chordblog.com/%E3%80%90%E5%B7%A6%E5%81%8F%E6%A0%91%E3%80%91%E6%B4%9B%E8%B0%B7-P3377-%C2%96%C2%96%C2%96%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%EF%BC%89.html"/>
    <id>chordblog.com/【左偏树】洛谷-P3377-左偏树（可并堆）.html</id>
    <published>2019-05-03T14:44:52.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，一开始有N个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：</p><p>操作1： 1 x y 将第x个数和第y个数所在的小根堆合并（若第x或第y个数已经被删除或第x和第y个数在用一个堆内，则无视此操作）</p><p>操作2： 2 x 输出第x个数所在的堆最小数，并将其删除（若第x个数已经被删除，则输出-1并无视删除操作）</p><a id="more"></a><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行包含两个正整数N、M，分别表示一开始小根堆的个数和接下来操作的个数。<br>第二行包含N个正整数，其中第i个正整数表示第i个小根堆初始时包含且仅包含的数。<br>接下来M行每行2个或3个正整数，表示一条操作，格式如下：<br>操作1 ： 1 x y<br>操作2 ： 2 x</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出包含若干行整数，分别依次对应每一个操作2所得的结果。<br>输入输出样例<br>输入样例#1：<br>5 5<br>1 5 4 2 3<br>1 1 5<br>1 2 5<br>2 2<br>1 4 2<br>2 2<br>输出样例#2：<br>1<br>2</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>当堆里有多个最小值时，优先删除原序列的靠前的，否则会影响后续操作1导致WA。<br>时空限制：1000ms,128M<br>数据规模：<br>对于30%的数据：N&lt;=10，M&lt;=10<br>对于70%的数据：N&lt;=1000，M&lt;=1000<br>对于100%的数据：N&lt;=100000，M&lt;=100000<br>样例说明：<br>初始状态下，五个小根堆分别为:{1}、{5}、{4}、{2}、{3}。<br>第一次操作，将第1个数所在的小根堆与第5个数所在的小根堆合并，故变为四个小根堆：{1,3}、{5}、{4}、{2}。<br>第二次操作，将第2个数所在的小根堆与第5个数所在的小根堆合并，故变为三个小根堆：{1,3,5}、{4}、{2}。<br>第三次操作，将第2个数所在的小根堆的最小值输出并删除，故输出1，第一个数被删除，三个小根堆为：{3,5}、{4}、{2}。<br>第四次操作，将第4个数所在的小根堆与第2个数所在的小根堆合并，故变为两个小根堆：{2,3,5}、{4}。<br>第五次操作，将第2个数所在的小根堆的最小值输出并删除，故输出2，第四个数被删除，两个小根堆为：{3,5}、{4}。<br>故输出依次为1、2。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>左偏树模板<br>注意路径压缩的处理，以及在判断的时候对于已经删除节点的判断。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> rt, dis, Son[<span class="number">2</span>], val;</span><br><span class="line">&#125;S[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y);</span><br><span class="line">rs = Union(rs, y);</span><br><span class="line"><span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis)</span><br><span class="line">swap(rs, ls);</span><br><span class="line">S[x].rt = S[ls].rt = S[rs].rt = x;</span><br><span class="line">S[x].dis = S[rs].dis + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S[x].val = <span class="number">-1</span>;</span><br><span class="line">S[ls].rt = ls;</span><br><span class="line">S[rs].rt = rs;</span><br><span class="line">S[x].rt = Union(ls, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; S[i].val;</span><br><span class="line">S[i].rt = i;</span><br><span class="line">&#125;</span><br><span class="line">S[<span class="number">0</span>].dis = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">int</span> xx = Get(b);</span><br><span class="line"><span class="keyword">int</span> yy = Get(c);</span><br><span class="line"><span class="keyword">if</span> (S[b].val == <span class="number">-1</span> || S[c].val == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (xx != yy) Union(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> xx = Get(b);</span><br><span class="line"><span class="keyword">if</span> (S[b].val == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; S[xx].val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Pop(xx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，一开始有N个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：&lt;/p&gt;
&lt;p&gt;操作1： 1 x y 将第x个数和第y个数所在的小根堆合并（若第x或第y个数已经被删除或第x和第y个数在用一个堆内，则无视此操作）&lt;/p&gt;
&lt;p&gt;操作2： 2 x 输出第x个数所在的堆最小数，并将其删除（若第x个数已经被删除，则输出-1并无视删除操作）&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="左偏树" scheme="chordblog.com/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【哈希】HRBUST 2300 下雪啦</title>
    <link href="chordblog.com/%E3%80%90%E5%93%88%E5%B8%8C%E3%80%91HRBUST-2300-%E4%B8%8B%E9%9B%AA%E5%95%A6.html"/>
    <id>chordblog.com/【哈希】HRBUST-2300-下雪啦.html</id>
    <published>2019-04-05T12:06:20.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 2500 MS    Memory Limit: 32768 K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>陈月亮最喜欢的季节就是冬天了，这不看着窗外飘起了雪花，陈月亮开心的跑出屋来看雪。但是迷迷糊糊的陈月亮不知道自己是在做梦还是真的下起了雪。突然她想起了一句话，在真实世界中是没有两片一样的雪花的。于是你的任务就是比较这场雪中的所有雪花，如果出现了两朵完全一致的雪花，则证明陈月亮是在梦中。</p><p>每朵雪花用六个整数表示，范围在（1 – 10000000）之间，表示雪花六个花瓣的长度，六个整数的先后出现顺序可能是顺时针顺序也可能是逆时针顺序，并且可能是从任意一个花瓣开始的。比如说对同一个花瓣，描述方法可能是1 2 3 4 5 6 或者 4 3 2 1 6 5</p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行为一个整数T，表示有T组测试数据。<br>每组测试数据第一行为一个整数N(0 &lt; N &lt;= 100000),表示雪花的数目。<br>接下来n行每行六个整数，描述一朵雪花。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>如果没有相同的雪花，输出“No two snowflakes are alike.”，否则输出“Twin snowflakes found.”</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>2<br>1 2 3 4 5 6<br>4 3 2 1 6 5</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Twin snowflakes found.</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>2016级新生程序设计全国邀请赛</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出N个序列，若两个序列从从任意位置开始的顺时针或逆时针方向读取序列所得到的序列相同，则这两个序列完全相同。找出所给的序列当中有没有两个相同的序列。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每个序列，我们都可以使用其的序列和当成一个哈希值，将同一个的哈希值存在一个线性表当中，对于新序列，我们只需要查询以存储过的哈希表当中是否有相同哈希值的元素。<br>当然，对于相同的哈希值，也有可能出现序列不相等的情况，这时候我们只需要用一个比对函数比对所有可能的序列出现情况即可。<br>对于序列插入哈希表的时候，若哈希值相同，但序列不相同的情况，我们需要存储到相同哈希值下的不同位置，这时候我们就需要对于每一个哈希值创建一个数组记录相同哈希值但是却是不同序列的情况。<br>所以说，vector\<int>是存储这道题的数据结构，也是这题当中哈希表的存储方式。</int></p><p>读入很大，可以考虑使用读入挂。<br>亲测使用读入挂比scanf要快一倍。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><code>877607    2300    Accepted    G++    355ms    7144k    软件-Chord    1985B    2019-04-03 21:30:03</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((a[o][<span class="number">0</span>] == a[t][i % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">1</span>] == a[t][(i + <span class="number">1</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">2</span>] == a[t][(i + <span class="number">2</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">3</span>] == a[t][(i + <span class="number">3</span>) % <span class="number">6</span>] &amp;&amp;</span><br><span class="line">             a[o][<span class="number">4</span>] == a[t][(i + <span class="number">4</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">5</span>] == a[t][(i + <span class="number">5</span>) % <span class="number">6</span>]) ||</span><br><span class="line">            (a[o][<span class="number">0</span>] == a[t][i % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">1</span>] == a[t][(i + <span class="number">5</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">2</span>] == a[t][(i + <span class="number">4</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">3</span>] == a[t][(i + <span class="number">3</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">4</span>] == a[t][(i + <span class="number">2</span>) % <span class="number">6</span>] &amp;&amp; a[o][<span class="number">5</span>] == a[t][(i + <span class="number">1</span>) % <span class="number">6</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">scan_d</span>(<span class="title">T</span> &amp;<span class="title">ret</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> sgn;</span><br><span class="line">    <span class="keyword">if</span> (c = getchar(), c == EOF)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>))</span><br><span class="line">        c = getchar();</span><br><span class="line">    sgn = (c == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    ret = (c == <span class="string">'-'</span>) ? <span class="number">0</span> : (c - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">while</span> (c = getchar(), c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ret = ret * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">    ret *= sgn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    scan_d(t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        scan_d(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">                scan_d(a[i][j]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Hash[maxn];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">                sum += a[i][j];</span><br><span class="line">            sum %= maxn;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Hash[sum].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(i, Hash[sum][j]))</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Hash[sum].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Twin snowflakes found."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No two snowflakes are alike."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 2500 MS    Memory Limit: 32768 K&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;陈月亮最喜欢的季节就是冬天了，这不看着窗外飘起了雪花，陈月亮开心的跑出屋来看雪。但是迷迷糊糊的陈月亮不知道自己是在做梦还是真的下起了雪。突然她想起了一句话，在真实世界中是没有两片一样的雪花的。于是你的任务就是比较这场雪中的所有雪花，如果出现了两朵完全一致的雪花，则证明陈月亮是在梦中。&lt;/p&gt;
&lt;p&gt;每朵雪花用六个整数表示，范围在（1 – 10000000）之间，表示雪花六个花瓣的长度，六个整数的先后出现顺序可能是顺时针顺序也可能是逆时针顺序，并且可能是从任意一个花瓣开始的。比如说对同一个花瓣，描述方法可能是1 2 3 4 5 6 或者 4 3 2 1 6 5&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
      <category term="哈希" scheme="chordblog.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【哈希】HRBUST 1013 Eqs</title>
    <link href="chordblog.com/%E3%80%90%E5%93%88%E5%B8%8C%E3%80%91HRBUST-1013-Eqs.html"/>
    <id>chordblog.com/【哈希】HRBUST-1013-Eqs.html</id>
    <published>2019-04-02T14:08:10.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 5000 MS    Memory Limit: 65536 K<br>Total Submit: 908(377 users)    Total Accepted: 479(332 users)    </p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Consider equations having the following form:<br>a1x13+ a2x23+ a3x33+ a4x43+ a5x53=0<br>The coefficients are given integers from the interval [-50,50].<br>It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}. </p><a id="more"></a><p>Determine how many solutions satisfy the given equation.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>For each test case :<br>Line 1: Five coefficients a1, a2, a3, a4, a5, separated by blanks.<br>Process to the end of file.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case :</p><p>Line 1: A single integer that is the number of the solutions for the given equation.(The output will fit in 32 bit signed integers.)</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>37 29 41 43 47</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>654</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个五元方程组，并给出五元方程组相关的参数，问有多少个可行解。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将a3x3^3+a4x4^3+ a5x5^3移到等式另一侧，无疑就变成一个右边的值是否左边有一个式子等于其，而左边方程式的所有值我们可以枚举一下，由于同一个值可能出现多个左边的等式等于其，所以我们也要解决一下冲突。<br>说白了就是hash,看等式右边是否存在一个值在左边的等式出现，且能产生这个值的等式有多少个。</p><p>很明显，我们建立哈希统计表的时候，应该表次数越少越好，不然会出现大量的表操作而浪费时间。</p><p>同时，注意清空表。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ull maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ull veryluck = <span class="number">13131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> luck = <span class="number">12500007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poi</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ull num;</span><br><span class="line">    poi *next;</span><br><span class="line">    <span class="keyword">int</span> cet;</span><br><span class="line">    poi()</span><br><span class="line">    &#123;</span><br><span class="line">        cet = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; poi;</span><br><span class="line"></span><br><span class="line">poi aa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get_Hash</span><span class="params">(ull num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num % veryluck) % maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ull num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Hash = get_Hash(num);</span><br><span class="line">    poi *t = aa + Hash;</span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;num == num)</span><br><span class="line">        &#123;</span><br><span class="line">            (t-&gt;cet)++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next = <span class="keyword">new</span> poi();</span><br><span class="line">    t = t-&gt;next;</span><br><span class="line">    t-&gt;num = num;</span><br><span class="line">    t-&gt;cet = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ull num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Hash = get_Hash(num);</span><br><span class="line">    poi *t = aa + Hash;</span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;num == num)</span><br><span class="line">            <span class="keyword">return</span> t-&gt;cet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(poi *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        Clear(t-&gt;next);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, c, d, e;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll x1 = <span class="number">-50</span>; x1 &lt;= <span class="number">50</span>; x1++)</span><br><span class="line">            <span class="keyword">if</span> (x1 != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (ll x2 = <span class="number">-50</span>; x2 &lt;= <span class="number">50</span>; x2++)</span><br><span class="line">                    <span class="keyword">if</span> (x2 != <span class="number">0</span>)</span><br><span class="line">                        insert((ull)(a * x1 * x1 * x1 + b * x2 * x2 * x2 + luck));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll x3 = <span class="number">-50</span>; x3 &lt;= <span class="number">50</span>; x3++)</span><br><span class="line">            <span class="keyword">if</span> (x3 != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (ll x4 = <span class="number">-50</span>; x4 &lt;= <span class="number">50</span>; x4++)</span><br><span class="line">                    <span class="keyword">if</span> (x4 != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> (ll x5 = <span class="number">-50</span>; x5 &lt;= <span class="number">50</span>; x5++)</span><br><span class="line">                            <span class="keyword">if</span> (x5 != <span class="number">0</span>)</span><br><span class="line">                                ans += Find((ull)((<span class="number">0</span> - (c * x3 * x3 * x3 + d * x4 * x4 * x4 + e * x5 * x5 * x5)) + luck));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (ull i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">            <span class="keyword">if</span> (aa[i].next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Clear(aa[i].next);</span><br><span class="line">                aa[i].next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 5000 MS    Memory Limit: 65536 K&lt;br&gt;Total Submit: 908(377 users)    Total Accepted: 479(332 users)    &lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Consider equations having the following form:&lt;br&gt;a1x13+ a2x23+ a3x33+ a4x43+ a5x53=0&lt;br&gt;The coefficients are given integers from the interval [-50,50].&lt;br&gt;It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}. &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="chordblog.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
      <category term="哈希" scheme="chordblog.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 61 ABCDF题解</title>
    <link href="chordblog.com/Educational-Codeforces-Round-61-ABCDF%E9%A2%98%E8%A7%A3.html"/>
    <id>chordblog.com/Educational-Codeforces-Round-61-ABCDF题解.html</id>
    <published>2019-03-14T13:51:53.000Z</published>
    <updated>2019-07-19T11:43:47.150Z</updated>
    
    <content type="html"><![CDATA[<p>Educational Codeforces Round 61 ABCDF题解<br><a id="more"></a></p><h2 id="A-Regular-Bracket-Sequence"><a href="#A-Regular-Bracket-Sequence" class="headerlink" title="A.Regular Bracket Sequence"></a>A.Regular Bracket Sequence</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你四种括号的数量，问是否存在一种组合方式让所有的括号匹配</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>水题，怎么操作都可以。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">  l = a * <span class="number">2</span> + b + c;</span><br><span class="line">  r = b + c + d * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; a == b &amp;&amp; b == c &amp;&amp; c == d)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (r == l)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span> &amp;&amp; (a == <span class="number">0</span> || d == <span class="number">0</span>))</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">  <span class="comment">// system("pause");</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Discounts"><a href="#B-Discounts" class="headerlink" title="B.Discounts"></a>B.Discounts</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你一系列的糖果，你有一些优惠券，你可以选择等同于某张优惠券相同数字个的糖果，并将其中最便宜的那个糖果免费拿，之后其他糖果全价。问对于不同数字的优惠券，最便宜的购买方案是什么。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>水题，排个序然后选则比较贵的前几个就行。</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line">ll p[maxn];</span><br><span class="line">ll aa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;p[i]);</span><br><span class="line">        ans += p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p, p + n, greater&lt;ll&gt;());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;aa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans - p[aa[i] - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Painting-the-Fence"><a href="#C-Painting-the-Fence" class="headerlink" title="C.Painting the Fence"></a>C.Painting the Fence</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一些油漆工刷模板，每个人刷的范围不一样，现在撤掉两个油漆工，问撤掉之后最大能刷的面积是都少。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先记录木板的每个部位被哪些油漆工刷了。然后统计每个油漆工对于只有一层油漆被刷的墙面的贡献，若一块墙面被两个油漆工刷了，统计一下这两个油漆工对于这块墙面的共同贡献。<br>之后暴力枚举一波，若删掉任意两个油漆工会让墙面少多少。少掉的数量就是：这两个油漆工对于当且仅当刷了一面墙的贡献加上他们俩合力刷了两面墙的贡献。</p><p>为什么超过三个油漆工刷过的墙面不统计？因为刷过三次的墙面怎么算贡献删掉两个油漆工都不会对这面墙有影响。</p><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> poi[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> one[maxn], two[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = x; j &lt;= y; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (poi[j][<span class="number">0</span>] &lt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                poi[j][++poi[j][<span class="number">0</span>]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                poi[j][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = poi[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//  cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            sum++;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            one[poi[i][<span class="number">1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">            two[poi[i][<span class="number">1</span>]][poi[i][<span class="number">2</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = min(cnt, one[i] + one[j] + two[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum - cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Stressful-Training"><a href="#D-Stressful-Training" class="headerlink" title="D.Stressful Training"></a>D.Stressful Training</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有N个学生，每个学生的电脑初始有一定量的电量，有一个充电器，每次可以给一个学生的电脑补充一定量的电，问最少需要每次补充的电量为多少即可让所有的学生都能挺过M的时间。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>二分寻找这个最小的充电电量，然后暴力贪心模拟，每次给电最少的学生充电。</p><p>怎么模拟呢？用有限队列维护每个学生电脑的电量，每个学生的电脑充一次电之后都可以继续运行一段的时间，每次统计从开始到每次充电之后学生电脑的总电量，除以耗电量，就是学生可以从开始坚持多少时间。然后若一开始学生坚持的时间小于当前时间，无疑是学生撑不到这个点了，返回false，若电量最少的学生能坚持的时间都比总时间长，那么直接范围true。可以完成模拟就说明当前这种充电的电量可以让每个学生坚持到最后，那么返回true。</p><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><p>ps: 2994 ms<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll a[maxn], b[maxn], n, k;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll time, id, power;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;time == a.time ? <span class="keyword">this</span>-&gt;id &gt; a.id : <span class="keyword">this</span>-&gt;time &gt; a.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; poi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p.push(poi&#123;a[i] / b[i], (ll)i, a[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poi t = p.top();</span><br><span class="line">        p.pop();</span><br><span class="line">        <span class="keyword">if</span> (t.time &lt; i)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t.time &gt;= k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        t.power += x;</span><br><span class="line">        t.time = t.power / b[t.id];</span><br><span class="line">        p.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e13</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1e13</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="F-Clear-the-String"><a href="#F-Clear-the-String" class="headerlink" title="F.Clear the String"></a>F.Clear the String</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给你一个字符串，每次可以删除一些相同的连续子串，问最少删除几次就可以把整个字符串完全删除。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>区间DP，挺简单的。<br><code>dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);</code><br>同时，当区间两端相等的时候，可以免费删除一次。</p><h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt;= n; size++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + size &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + size;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[j])</span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt;= j; mid++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>不能再沉迷与拯救华盛顿了啊！！！！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Educational Codeforces Round 61 ABCDF题解&lt;br&gt;
    
    </summary>
    
      <category term="竞赛题解" scheme="chordblog.com/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforcess" scheme="chordblog.com/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/Codeforcess/"/>
    
    
  </entry>
  
  <entry>
    <title>【区间DP】HRBUST 1818/1819 石子合并问题</title>
    <link href="chordblog.com/%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91HRBUST-1818-1819-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F.html"/>
    <id>chordblog.com/【区间DP】HRBUST-1818-1819-石子游戏.html</id>
    <published>2019-03-09T10:44:16.000Z</published>
    <updated>2019-07-19T11:43:47.166Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<br><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1818" target="_blank" rel="noopener">石子合并问题-直线版</a><br><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1819" target="_blank" rel="noopener">狮子合并问题-圆形版</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>相邻石子合并，每次合并的代价是两堆石子的重量之和，问最大代价和最小代价。<br>直线版就是石子的排列是一条直线，圆形版是成一个环装结构，可以合并头尾两端的石子堆。<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>状态转移方程:<br><code>dp[i][j] = min/max(dp[i][j],dp[i][mid]+dp[mid+1][j]+sum[j]-sum[i-1]);</code><br>圆形版只要再在原先的末尾再接上一个相同的石子串即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>直线版<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp1[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; dp[i][i];</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + dp[i][i];</span><br><span class="line">            dp[i][i] = dp1[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; n; size++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + size &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + size;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                    dp1[i][j] = max(dp1[i][j], dp1[i][mid] + dp1[mid + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">' '</span> &lt;&lt; dp1[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>圆形版<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp1[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            dp[i][i] = dp1[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i + n] = sum[i + n - <span class="number">1</span>] + a[i];</span><br><span class="line">            dp[i + n][i + n] = dp1[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; <span class="number">2</span> * n; size++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + size &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + size;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                    dp1[i][j] = max(dp1[i][j], dp1[i][mid] + dp1[mid + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ansmin = <span class="number">0x3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> ansmax = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ansmin = min(dp[i][i + n - <span class="number">1</span>], ansmin);</span><br><span class="line">            ansmax = max(dp1[i][i + n - <span class="number">1</span>], ansmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ansmin &lt;&lt; <span class="string">' '</span> &lt;&lt; ansmax &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;br&gt;&lt;a href=&quot;http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;amp;a=showProblem&amp;amp;problem_id=1818&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;石子合并问题-直线版&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;amp;a=showProblem&amp;amp;problem_id=1819&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狮子合并问题-圆形版&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;相邻石子合并，每次合并的代价是两堆石子的重量之和，问最大代价和最小代价。&lt;br&gt;直线版就是石子的排列是一条直线，圆形版是成一个环装结构，可以合并头尾两端的石子堆。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【思维】HRBUST 1909 理工门外的树</title>
    <link href="chordblog.com/%E3%80%90%E6%80%9D%E7%BB%B4%E3%80%91HRBUST-1909-%E7%90%86%E5%B7%A5%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91.html"/>
    <id>chordblog.com/【思维】HRBUST-1909-理工门外的树.html</id>
    <published>2019-03-06T12:29:57.000Z</published>
    <updated>2019-07-19T11:43:47.182Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 1000 MS    Memory Limit: 32768 K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>哈尔滨修地铁了~理工门口外长度为N的马路上有一排树，已知两棵树之间的距离都是1m。现在把马路看成是一个数轴，马路的一端在数轴0的位置，另一端在N的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行有两个整数N（1 &lt;= N &lt;= 1,000,000）和M（1 &lt;= M &lt;= 10,000），N代表马路的长度，M代表区域的数目，N和M之间用一个空格隔开。接下来的M行每行包含两个不同整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 </p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。 </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>500 3150 300100 200470 471</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>298</code></pre><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>周洲 @hrbust</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>RT，给出m次操作，移除一段区间内的所有树，问剩下多少树。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一种很巧妙的做法<br>1，标记起点和终点，让其一正一负。<br>2，设置一个flag，加上所有的点的权值。<br>若加完之后flag值仍然为0，说明该点不在任何移除区间之内，相反就在。很明显任何一个区间的收尾两端被flag相加之后必然为0。<br>注意处理一下区间终点即可。因为端点的树也被移走了。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            a[x]--;</span><br><span class="line">            a[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag += a[i];</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                sum++;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; a[i] &gt; <span class="number">0</span>)</span><br><span class="line">                sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 1000 MS    Memory Limit: 32768 K&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;哈尔滨修地铁了~理工门口外长度为N的马路上有一排树，已知两棵树之间的距离都是1m。现在把马路看成是一个数轴，马路的一端在数轴0的位置，另一端在N的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。&lt;br&gt;
    
    </summary>
    
      <category term="思维" scheme="chordblog.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="chordblog.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】蓝桥杯 格子刷油漆</title>
    <link href="chordblog.com/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86.html"/>
    <id>chordblog.com/【动态规划】蓝桥杯-格子刷油漆.html</id>
    <published>2019-02-28T02:17:08.000Z</published>
    <updated>2019-07-19T11:43:47.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。<br><img src="/photo/gz.jpg" alt="格子刷油漆"><br>　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）<br>　　比如：a d b c e f 就是合格的刷漆顺序。<br>　　c e f d a b 是另一种合适的方案。<br>　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。<br><a id="more"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入数据为一个正整数（不大于1000）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出数据为一个正整数。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>2</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>24</code></pre><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>3</code></pre><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>96</code></pre><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>22</code></pre><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>359635897</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个2×n的网格，你可以走相邻的格子，问在不走已走过的格子的情况下，有多少种可行方案遍历所有的格子。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，分两种情况讨论。<br>设置两个数组a,b，a数组表示从某个点出发任意点结束的所有情况。b数组表示从某个点出发且结束点为同列的另一个格子。<br>假设遍历格子次序从左到右。</p><p>一、从四个角出发，遍历所有的格子。对于这种情况又分两种情况讨论。<br>  <strong>遍历中的遍历全部格子 = 遍历当前格子和其左边的格子。</strong></p><ol><li>第一种，从当前格子出发，结束为当前格子<strong>同列相对</strong>的格子。满足b数组要求，由于第一步可以走到左上或者左下，所以<code>b[i] = 2* ...</code> ，又因为走到左上或者左下的格子之后又变成了一个相同的问题，所以转移方程为<code>b[i] = 2*b[i-1]</code></li><li>第二种，从当前格子出发，结束位置为<strong>任意</strong>格子。满足a数组要求，第一步分三种情况<ol><li><strong>向下走</strong>，那么下一步就变成了从i-i位置开始的相同问题，所以这一种情况的转移方程为<code>2*a[i-1]</code></li><li>向<strong>左下方</strong>走，此时又有两种情况<ol><li>先往<strong>右</strong>走，之后往<strong>左斜上方</strong>走，走到出发位置的左手边，此时又变成了从i-2位置遍历所有的格子的问题，转移方程为<code>2*a[i-2]</code></li><li>先向<strong>左</strong>走，遍历完所有格子之后回到正上方的格子。变成第一种情况的i-1版本，转移方程为<code>b[i-1]</code>。</li></ol></li><li>向<strong>左</strong>方向走。此时可以分成两种情况。<ol><li>向<strong>右下方</strong>走，之后只能往<strong>左</strong>走一格，然后可以往左上或者左手边走，然后又变成了一个，从i-2的格子出发遍历所有格子的问题，转移方程为<code>2*a[i-2]</code></li><li>向左遍历完所有的格子最后回到同列相对的格子，转移方程为<code>b[i-1]</code></li></ol></li></ol></li></ol><p>整理一下在这个遍历当中的所有转移方程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b[i] = <span class="number">2</span>*b[i<span class="number">-1</span>]</span><br><span class="line">a[i] = <span class="number">4</span>*a[i<span class="number">-2</span>] + <span class="number">2</span>*a[i<span class="number">-1</span>] + <span class="number">2</span>*b[i<span class="number">-1</span>] = <span class="number">4</span>*a[i<span class="number">-2</span>] + <span class="number">2</span>*a[i<span class="number">-1</span>] + b[i]</span><br></pre></td></tr></table></figure></p><p>因为一个长方体有四个角，所以遍历完所有的长度之后，ans = 4*a[n]。<br>二、从非四个角出发，遍历所有的格子。<br>首先明确一点，从非四个角的点出发，都不可以第一步向下走，因为根据题目规则，这样行走只能遍历一半的点。<br>那么就变成了两种情况。</p><ol><li>第一种，从当前的格子出发，先向左走，回到当前格子同列的格子之后，再遍历右边所有的格子。转移方程为<code>b[i] * a[n-i]*2</code>因为遍历右边格子的时候可以选择从<strong>右上</strong>的格子开始遍历也可以选择从<strong>右</strong>手边的格子开始遍历，所以a[n-i]需要×2。<strong>注意，这里遍历完一遍之后并没有遍历完所有的情况，所以左右情况应该相乘而不是相加。</strong></li><li>第二种，从当前的格子出发，先往右走，回到当前格子同列的格子之后，再遍历左边的格子。原理同第一种，不再赘述。<code>b[n-i+1]*a[i-1]*2</code></li></ol><p>整理一下这两种情况。<br>由于每次可以从上方的格子开始遍历，也可以从下方的格子开始遍历，所以实际计算之后结果还要×2。<br>每一步的循环都得加到总结果当中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">       sum += (<span class="number">2</span> * ((b[i] * a[n - i] * <span class="number">2</span>) % mod + (b[n - i + <span class="number">1</span>] * a[i - <span class="number">1</span>] * <span class="number">2</span>) % mod)) % mod;</span><br><span class="line">       sum %= mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">评测结果正确</span><br><span class="line">得分<span class="number">100</span></span><br><span class="line">CPU使用<span class="number">0</span>ms</span><br><span class="line">内存使用<span class="number">2.449</span>MB</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*先预处理出前两步的数组*/</span></span><br><span class="line">    a[<span class="number">1</span>] = b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">6</span>, b[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        b[i] %= mod;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] * <span class="number">2</span> + a[i - <span class="number">2</span>] * <span class="number">4</span> + b[i]; <span class="comment">//第一种情况。</span></span><br><span class="line">        a[i] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">4</span> * a[n] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += (<span class="number">2</span> * ((b[i] * a[n - i] * <span class="number">2</span>) % mod + (b[n - i + <span class="number">1</span>] * a[i - <span class="number">1</span>] * <span class="number">2</span>) % mod)) % mod; <span class="comment">//第二种情况。</span></span><br><span class="line">        sum %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"24"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sovle();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。&lt;br&gt;&lt;img src=&quot;/photo/gz.jpg&quot; alt=&quot;格子刷油漆&quot;&gt;&lt;br&gt;　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）&lt;br&gt;　　比如：a d b c e f 就是合格的刷漆顺序。&lt;br&gt;　　c e f d a b 是另一种合适的方案。&lt;br&gt;　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。&lt;br&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="chordblog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="chordblog.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="动态规划" scheme="chordblog.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【斯普莱格-格隆第定理】蓝桥杯　高僧斗法</title>
    <link href="chordblog.com/%E3%80%90%E6%96%AF%E6%99%AE%E8%8E%B1%E6%A0%BC-%E6%A0%BC%E9%9A%86%E7%AC%AC%E5%AE%9A%E7%90%86%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95.html"/>
    <id>chordblog.com/【斯普莱格-格隆第定理】蓝桥杯-高僧斗法.html</id>
    <published>2019-02-25T13:46:37.000Z</published>
    <updated>2019-07-19T11:43:47.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。<br>　　节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)<br>　　两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。<br>　　两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。<br>　　对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。<br><a id="more"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>1 5 9</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>1 4</code></pre><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>1 5 8 10</code></pre><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>1 3</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你Ｎ个和尚，每个和尚可以网上移动任意距离，但是不能超过他前面的第一个和尚。依次轮流移动和尚，直至轮到移动的一方无法移动为输。问先手是否有一种移动方式必胜，有则输出移动方式。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>斯普莱格–格隆第定理：在组合博弈论中，斯普莱格–格隆第定理证明， 所有的一般胜利条件下的无偏博弈都能转换成尼姆数表达的尼姆堆博弈。 一个无偏博弈的尼姆值定义为这个博弈的等价尼姆数。<br>两两和尚之间的距离看成一个堆，如1,3,5,7，则看成(1,3),(5,7)，若为基数个，舍去最后一个和尚。<br>再用暴力枚举出第一种可能的移动情况。<br>为何两两？非两两的成堆会导致一个堆移动的时候对其余的堆发生影响，破坏了Nim博弈的性质。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">评测结果正确</span><br><span class="line">得分<span class="number">100</span></span><br><span class="line">CPU使用<span class="number">0</span>ms</span><br><span class="line">内存使用<span class="number">1.304</span>MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt;= num; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ^= (a[i + <span class="number">1</span>] - a[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans) <span class="comment">//若移动之后为Ｎ状态，此方案不可行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//为０即为Ｐ状态，可行。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%c"</span>, &amp;a[++num], &amp;p);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i] + <span class="number">1</span>; j &lt; a[i + <span class="number">1</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> back = a[i];</span><br><span class="line">            a[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (judge())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, back, j);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = back;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。&lt;br&gt;　　节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)&lt;br&gt;　　两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。&lt;br&gt;　　两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。&lt;br&gt;　　对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。&lt;br&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="chordblog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="Nim博弈" scheme="chordblog.com/tags/Nim%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>【dfs】蓝桥杯　网络寻路</title>
    <link href="chordblog.com/%E3%80%90dfs%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%BD%91%E7%BB%9C%E5%AF%BB%E8%B7%AF.html"/>
    <id>chordblog.com/【dfs】蓝桥杯-网络寻路.html</id>
    <published>2019-02-21T03:29:29.000Z</published>
    <updated>2019-07-19T11:43:47.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。</p><p>源地址和目标地址可以相同，但中间节点必须不同。</p><p>如下图所示的网络。<br><img src="/photo/wlxl.jpg" alt="图一"></p><p>1 -&gt; 2 -&gt; 3 -&gt; 1 是允许的<br>1 -&gt; 2 -&gt; 1 -&gt; 2 或者 1 -&gt; 2 -&gt; 3 -&gt; 2 都是非法的。</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据的第一行为两个整数N M，分别表示节点个数和连接线路的条数(1&lt;=N&lt;=10000; 0&lt;=M&lt;=100000)。<br>接下去有M行，每行为两个整数 u 和 v，表示节点u 和 v 联通(1&lt;=u,v&lt;=N , u!=v)。<br>输入数据保证任意两点最多只有一条边连接，并且没有自己连自己的边，即不存在重边和自环。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示满足要求的路径条数。</p><h2 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h2><pre><code>3 31 22 31 3</code></pre><h2 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h2><pre><code>6</code></pre><h2 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h2><pre><code>4 41 22 33 11 4</code></pre><h2 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h2><pre><code>10</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个无向图，问走四步且中间两点不同，起始两点可相同可不同，且必须中间两点为两个除了起始点之外不同的点的路径有多少条。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dfs，直接记录经过点的次数，对于经过点的次数为３的结果有效路径，我们可以再判断一下能不能到达终点，能的话结果加１．其他情况正常判断能否经过４个点且满足题意即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>评测结果    正确<br>得分    100<br>CPU使用    734ms<br>内存使用    4.199MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[M];</span><br><span class="line"><span class="keyword">int</span> start, vis[M], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> go)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (go == <span class="number">4</span>) <span class="comment">//经过了四个点且中间两个点与起始点不同</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[root] = <span class="number">1</span>; <span class="comment">//当前点已经走过，标记一下。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[root].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[root][i] == start &amp;&amp; go == <span class="number">3</span>) <span class="comment">//恰好经过三个点，下一个点可以到达起点的情况。</span></span><br><span class="line">            ans++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[root][i]] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(a[root][i], go + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[root] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        a[x].push_back(y);</span><br><span class="line">        a[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        start = i; <span class="comment">//记录起始点。</span></span><br><span class="line">        dfs(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。&lt;/p&gt;
&lt;p&gt;源地址和目标地址可以相同，但中间节点必须不同。&lt;/p&gt;
&lt;p&gt;如下图所示的网络。&lt;br&gt;&lt;img src=&quot;/photo/wlxl.jpg&quot; alt=&quot;图一&quot;&gt;&lt;/p&gt;
&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 1 是允许的&lt;br&gt;1 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; 2 或者 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 2 都是非法的。&lt;/p&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="chordblog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="dfs" scheme="chordblog.com/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>【dfs】蓝桥杯 历届试题 危险系数</title>
    <link href="chordblog.com/%E3%80%90dfs%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98-%E5%8D%B1%E9%99%A9%E7%B3%BB%E6%95%B0.html"/>
    <id>chordblog.com/【dfs】蓝桥杯-历届试题-危险系数.html</id>
    <published>2019-02-18T12:10:25.000Z</published>
    <updated>2019-07-19T11:43:47.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>抗日战争时期，冀中平原的地道战曾发挥重要作用。<br>地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。<br>我们来定义一个危险系数DF(x,y)：<br>对于两个站点x和y (x != y), 如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。</p><p>本题的任务是：已知网络结构，求两站点之间的危险系数。<br><a id="more"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第一行包含2个整数n(2 &lt;= n &lt;= 1000), m(0 &lt;= m &lt;= 2000),分别代表站点数，通道数；<br>接下来m行，每行两个整数 u,v (1 &lt;= u, v &lt;= n; u != v)代表一条通道；<br>最后1行，两个数u,v，代表询问两点之间的危险系数DF(u, v)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，如果询问的两点不连通则输出-1.</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>7 6<br>1 3<br>2 3<br>3 4<br>3 5<br>4 5<br>5 6<br>1 6</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个无向图，问从给定起点到终点的所有路径当中哪些点是删除之后所有的路径都无法使起点到达终点。输出这类节点的数量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>所谓的这类点，无疑就是所有路径都通过的点，我们只要找到那些所有路径都存在的点就是题目所求。<br>我们可以通过统计每个点被路径通过的次数，最后审查每个点，若某个点被路径通过的次数等于总的路径条数，那么这个点就是关键点。<br>找到从起点到终点的路径用dfs就可以，到达终点之后把该条路径上的点全部计数一遍，路径个数++，最后比较一下就好。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>一开始中间的各个路径拿vector写的，又WA又T…..后面拿数组去模拟，０ms．<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">评测结果正确</span><br><span class="line">得分<span class="number">100</span></span><br><span class="line">CPU使用<span class="number">0</span>ms</span><br><span class="line">内存使用<span class="number">4.386</span>MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> tvis[maxn];</span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"><span class="keyword">int</span> s, e;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == e)</span><br><span class="line">    &#123;</span><br><span class="line">        flag++; <span class="comment">//路径条数自增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            vis[t[i]]++;</span><br><span class="line">        <span class="comment">/*将这条可达路径上的点全部计数。*/</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[root].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tvis[a[root][i]] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            t[size] = root; <span class="comment">/*记录路径*/</span></span><br><span class="line">            tvis[root] = <span class="number">1</span>; <span class="comment">/*当前节点标记已经走过。*/</span></span><br><span class="line">            <span class="comment">//printf("root:%d i:%d a[root][i]:%d\n", root, i, a[root][i]);</span></span><br><span class="line">            <span class="comment">//getchar();</span></span><br><span class="line">            dfs(a[root][i], size + <span class="number">1</span>); <span class="comment">//到下一个节点。</span></span><br><span class="line">            t[size] = <span class="number">0</span>;               <span class="comment">//回溯</span></span><br><span class="line">            tvis[root] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        a[x].push_back(y);</span><br><span class="line">        a[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;e);</span><br><span class="line">    <span class="comment">//printf("%d", a[5][0]);</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[s].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(a[s][i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//    printf("%d%c", vis[i], i == n ? '\n' : ' ');</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == flag)</span><br><span class="line">            ans++;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sovle();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;抗日战争时期，冀中平原的地道战曾发挥重要作用。&lt;br&gt;地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。&lt;br&gt;我们来定义一个危险系数DF(x,y)：&lt;br&gt;对于两个站点x和y (x != y), 如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。&lt;/p&gt;
&lt;p&gt;本题的任务是：已知网络结构，求两站点之间的危险系数。&lt;br&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="chordblog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="搜索" scheme="chordblog.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="暴力" scheme="chordblog.com/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>【模拟】蓝桥杯 幸运数</title>
    <link href="chordblog.com/%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%B9%B8%E8%BF%90%E6%95%B0.html"/>
    <id>chordblog.com/【模拟】蓝桥杯-幸运数.html</id>
    <published>2019-02-17T09:43:34.000Z</published>
    <updated>2019-07-19T11:43:47.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成。<br>首先从1开始写出自然数1,2,3,4,5,6,….<br>1 就是第一个幸运数。<br>我们从2这个数开始。把所有序号能被2整除的项删除，变为：<br>1 _ 3 _ 5 _ 7 _ 9 ….<br>把它们缩紧，重新记序，为：<br>1 3 5 7 9 …. 。<br>这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, …</p><p>此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,…)</p><p>最后剩下的序列类似：<br>1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, …<br><a id="more"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个正整数m n, 用空格分开 (m &lt; n &lt; 1000 *1000)</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>程序输出 位于m和n之间的幸运数的个数（不包含m和n）。</p><h2 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h2><p>1 20</p><h2 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h2><p>5</p><h2 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h2><p>30 69</p><h2 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h2><p>8</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>RT</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目说明直接模拟即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">评测结果正确</span><br><span class="line">得分<span class="number">100</span></span><br><span class="line">CPU使用<span class="number">62</span>ms</span><br><span class="line">内存使用<span class="number">1.875</span>MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">1000007</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> go = start;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    go++;</span><br><span class="line">                    <span class="keyword">if</span> (go % i == <span class="number">0</span>)</span><br><span class="line">                        a[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在oeis上找到的一个求幸运数的c++程序，收藏一下。<br><a href="http://oeis.org/A000959/a000959.cpp.txt" target="_blank" rel="noopener">http://oeis.org/A000959/a000959.cpp.txt</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line"><span class="comment">// This program generates a b-file for the lucky numbers (A000959)</span></span><br><span class="line"><span class="comment">// Run "lucky &lt;elems&gt;" to print elements 1 through &lt;elems&gt;</span></span><br><span class="line"><span class="comment">// It uses a "virtual sieve" and requires O(&lt;elems&gt;) space</span></span><br><span class="line"><span class="comment">// It runs as fast of faster than an explicit sieving algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Obtain number of elements from command line</span></span><br><span class="line">    <span class="keyword">unsigned</span> elems = argc &lt;= <span class="number">1</span> ? <span class="number">10000</span> : atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a vector for our seive</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ulong&gt; lucky;</span><br><span class="line">lucky.resize(elems);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set and print the first two elements explicitly</span></span><br><span class="line">    <span class="comment">// Indexing from 0 simplifies the computation</span></span><br><span class="line"><span class="keyword">if</span> (elems &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">lucky[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (elems &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lucky[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"2 3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g is the largest index with lucky[g] &lt;= n+1</span></span><br><span class="line">    <span class="keyword">unsigned</span> g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the nth lucky number for 2 &lt;= n &lt;= elems</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> n = <span class="number">2</span>; n &lt; elems; n++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Update g to largest index with lucky[g] &lt;= n+1</span></span><br><span class="line">        <span class="keyword">if</span> (lucky[g+<span class="number">1</span>] &lt;= n+<span class="number">1</span>) g++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now we are going to trace the position k of the nth</span></span><br><span class="line">        <span class="comment">// lucky number backwards through the sieving process.</span></span><br><span class="line">        <span class="comment">// k is the nth lucky number, so it is at position n</span></span><br><span class="line">        <span class="comment">// after all the sieves.</span></span><br><span class="line">        ulong k = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If lucky[i] &gt; n+1, the sieve on lucky[i] does not alter</span></span><br><span class="line">        <span class="comment">// the position of the nth lucky number, that is, does not</span></span><br><span class="line">        <span class="comment">// alter k. So we need to run backwards through the sieves</span></span><br><span class="line">        <span class="comment">// for which lucky[i] &lt;= n+1. The last such sieve is the</span></span><br><span class="line">        <span class="comment">// sieve for lucky[g], by definition of g.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// So, we run backwards through the sieves for lucky[g]</span></span><br><span class="line">        <span class="comment">// down to the sieve for lucky[1] = 3.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = g; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// Here k is the position of the nth lucky number</span></span><br><span class="line">            <span class="comment">// after the sieve on lucky[i]. Adjust the position</span></span><br><span class="line">            <span class="comment">// prior to the sieve on lucky[i].</span></span><br><span class="line">            k = k*lucky[i]/(lucky[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here k is the position of the nth lucky number prior to</span></span><br><span class="line">        <span class="comment">// sieve on 3, that is, after the sieve on 2. Adjust the</span></span><br><span class="line">        <span class="comment">// position prior to the sieve on 2.</span></span><br><span class="line">        k = <span class="number">2</span>*k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here k is the position of the nth lucky number prior to</span></span><br><span class="line">        <span class="comment">// the sieve on 2, that is, within the natural numbers</span></span><br><span class="line">        <span class="comment">// (1, 2, 3, ...) indexed from 0. So the nth lucky number is</span></span><br><span class="line">        lucky[n] = k+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust n for 1-indexing and print our new value</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n+<span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; lucky[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// And we are done</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成。&lt;br&gt;首先从1开始写出自然数1,2,3,4,5,6,….&lt;br&gt;1 就是第一个幸运数。&lt;br&gt;我们从2这个数开始。把所有序号能被2整除的项删除，变为：&lt;br&gt;1 _ 3 _ 5 _ 7 _ 9 ….&lt;br&gt;把它们缩紧，重新记序，为：&lt;br&gt;1 3 5 7 9 …. 。&lt;br&gt;这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, …&lt;/p&gt;
&lt;p&gt;此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,…)&lt;/p&gt;
&lt;p&gt;最后剩下的序列类似：&lt;br&gt;1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, …&lt;br&gt;
    
    </summary>
    
      <category term="模拟" scheme="chordblog.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="chordblog.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>【树的直径】蓝桥杯 大臣的旅费</title>
    <link href="chordblog.com/%E3%80%90%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E3%80%91%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%A4%A7%E8%87%A3%E7%9A%84%E6%97%85%E8%B4%B9.html"/>
    <id>chordblog.com/【树的直径】蓝桥杯-大臣的旅费.html</id>
    <published>2019-02-17T04:12:46.000Z</published>
    <updated>2019-07-19T11:43:47.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p><p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</p><p>J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。</p><p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p><p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数<br>城市从1开始依次编号，1号城市为首都。<br>接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条）<br>每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示大臣J最多花费的路费是多少。</p><h2 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h2><pre><code>51 2 21 3 12 4 52 5 4</code></pre><h2 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h2><pre><code>135</code></pre><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>大臣J从城市4到城市5要花费135的路费。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>RT<br>找一条权值最长的路。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始拿dfs + 邻接表 就一顿暴力跑，最后一组数据估计数据大于1e5 然后RE了，过了75%。<br>之后用结构体+vector优化了一下空间结构，TLE<br>最后没办法，只好老老实实求树的直径就过了。<br>求树的直径只需从树的根开始dfs求一条离根最长的路的节点，之后将这个节点当做根，在dfs求一个到新根的最长路就是树的直径。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>PS：这题描述真的不清楚，网上有些代码写的是真的丑【自己写的明明更丑啊喂<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Poi</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> end, need;</span><br><span class="line">    Poi(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : end(a), need(b) &#123;&#125;</span><br><span class="line">&#125; poi;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;poi&gt; p[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> t1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> tans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[start].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[p[start][i].end] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[p[start][i].end] = <span class="number">1</span>;</span><br><span class="line">            dfs(p[start][i].end, tans + p[start][i].need);</span><br><span class="line">            vis[p[start][i].end] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tans &gt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 = start;</span><br><span class="line">        ans = tans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        p[x].push_back(Poi(y, z));</span><br><span class="line">        p[y].push_back(Poi(x, z));</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    vis[t1] = <span class="number">1</span>;</span><br><span class="line">    dfs(t1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> vvv = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= ans; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vvv += (i + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, vvv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sovle();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。&lt;/p&gt;
&lt;p&gt;为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。&lt;/p&gt;
&lt;p&gt;J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。&lt;/p&gt;
&lt;p&gt;聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。&lt;/p&gt;
&lt;p&gt;J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？&lt;/p&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="chordblog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="chordblog.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="树" scheme="chordblog.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【递归画图】POJ 2083 Fractal</title>
    <link href="chordblog.com/%E3%80%90%E9%80%92%E5%BD%92%E7%94%BB%E5%9B%BE%E3%80%91POJ-2083-Fractal.html"/>
    <id>chordblog.com/【递归画图】POJ-2083-Fractal.html</id>
    <published>2019-02-16T05:11:58.000Z</published>
    <updated>2019-07-19T11:43:47.260Z</updated>
    
    <content type="html"><![CDATA[<p>Time Limit: 1000MS        Memory Limit: 30000K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same “type” of structures must appear on all scales.<br>A box fractal is defined as below :<br>A box fractal of degree 1 is simply<br>X<br>A box fractal of degree 2 is<br>X X<br>X<br>X X<br>If using B(n - 1) to represent the box fractal of degree n - 1, then a box fractal of degree n is defined recursively as following<br>B(n - 1)        B(n - 1)</p><pre><code>B(n - 1)</code></pre><p>B(n - 1)        B(n - 1)</p><p>Your task is to draw a box fractal of degree n.<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of several test cases. Each line of the input contains a positive integer n which is no greater than 7. The last line of input is a negative integer −1 indicating the end of input.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, output the box fractal using the ‘X’ notation. Please notice that ‘X’ is an uppercase letter. Print a line with only a single dash after each test case.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>2<br>3<br>4<br>-1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>X<br>-<br>X X<br> X<br>X X<br>-<br>X X   X X<br> X     X<br>X X   X X<br>   X X<br>    X<br>   X X<br>X X   X X<br> X     X<br>X X   X X<br>-<br>X X   X X         X X   X X<br> X     X           X     X<br>X X   X X         X X   X X<br>   X X               X X<br>    X                 X<br>   X X               X X<br>X X   X X         X X   X X<br> X     X           X     X<br>X X   X X         X X   X X<br>         X X   X X<br>          X     X<br>         X X   X X<br>            X X<br>             X<br>            X X<br>         X X   X X<br>          X     X<br>         X X   X X<br>X X   X X         X X   X X<br> X     X           X     X<br>X X   X X         X X   X X<br>   X X               X X<br>    X                 X<br>   X X               X X<br>X X   X X         X X   X X<br> X     X           X     X<br>X X   X X         X X   X X<br>-</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>Shanghai 2004 Preliminary</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>根据样例画图。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最小子图就是X，若当前是最小子图就在当前位置画一个X，<br>若不是，当前图下五个最小子图的位置，继续递归。</p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>预处理 + printf TLE<br>预处理 + putchar 15ms<br>直接putchar 0ms</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>Problem: 2083        User: pengrj<br>Memory: 4668K        Time: 0MS<br>Language: G++        Result: Accepted<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>][<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">2</span>; j++)</span><br><span class="line">        m *= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        a[size][x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(size, x, y, i - <span class="number">1</span>);</span><br><span class="line">        print(size, x, y + m * <span class="number">2</span>, i - <span class="number">1</span>);</span><br><span class="line">        print(size, x + m, y + m, i - <span class="number">1</span>);</span><br><span class="line">        print(size, x + <span class="number">2</span> * m, y, i - <span class="number">1</span>);</span><br><span class="line">        print(size, x + <span class="number">2</span> * m, y + <span class="number">2</span> * m, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(n, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">pow</span>(<span class="number">3</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[n][i][j] == <span class="number">1</span> ? <span class="built_in">putchar</span>(<span class="string">'X'</span>) : <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == size - <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time Limit: 1000MS        Memory Limit: 30000K&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same “type” of structures must appear on all scales.&lt;br&gt;A box fractal is defined as below :&lt;br&gt;A box fractal of degree 1 is simply&lt;br&gt;X&lt;br&gt;A box fractal of degree 2 is&lt;br&gt;X X&lt;br&gt;X&lt;br&gt;X X&lt;br&gt;If using B(n - 1) to represent the box fractal of degree n - 1, then a box fractal of degree n is defined recursively as following&lt;br&gt;B(n - 1)        B(n - 1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;B(n - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;B(n - 1)        B(n - 1)&lt;/p&gt;
&lt;p&gt;Your task is to draw a box fractal of degree n.&lt;br&gt;
    
    </summary>
    
      <category term="思维" scheme="chordblog.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="递归" scheme="chordblog.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="画图" scheme="chordblog.com/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
</feed>
